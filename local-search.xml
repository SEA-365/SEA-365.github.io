<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录-20230221</title>
    <link href="/2023/02/21/%E8%AE%B0%E5%BD%95-20230221/"/>
    <url>/2023/02/21/%E8%AE%B0%E5%BD%95-20230221/</url>
    
    <content type="html"><![CDATA[<h2 id="记录-20230221"><a href="#记录-20230221" class="headerlink" title="记录-20230221"></a>记录-20230221</h2><p>今天是2023年2月21日上午10点，农历二月二，记录一下近期的学习进度还有生活感想。</p><h3 id="LeetCodde刷题"><a href="#LeetCodde刷题" class="headerlink" title="LeetCodde刷题"></a>LeetCodde刷题</h3><p>研一已经过去大半了，LeetCode刷题数量在昨天才到60，还得加油啊啊。</p><p>写了数据结构、回溯算法、动态规划和贪心算法相关的一些题，其中动态规划的题感觉挺难的，还有贪心算法相关的题目，有时候觉得很简单，有时候完全没有思路，似乎没有体会到贪心思想的精髓，还得加油加油加油啊！</p><p>争取研一结束LeetCode突破200道题！！</p><h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><p>到昨天为止，学完了集合这一个大章节，果然，本科课堂上学到的知识不过是一丢丢，学计算机还得自己课后多花时间啊。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>上周发现自己的生活有点单调，学完Java，就刷LeetCode，然后又学Java，，，，</p><p>于是，加入了MySQL的学习，记得上次学习这个还是在大二，基本全忘记了，赶紧捡起来。</p><h3 id="生活感想"><a href="#生活感想" class="headerlink" title="生活感想"></a>生活感想</h3><p>主要想记录一下目前的生活状态，可能毕业之后再回来看会有更多的感悟吧。</p><p>研一下学期</p><p>正月初七从家里出发返校，</p><p>初九开始学校实验室上班，</p><p>2月2日软件所春节假期结束，我们开始线下去软件所上班，</p><p>一开始还挺难受，</p><p>因为得每天骑共享单车通勤，</p><p>后来发现在学校实验室的同学们得天天加班其实更难受，</p><p>于是就平衡了，</p><p>后来所里的老师安排了一项类似运维的工作给我，</p><p>就很舒服了，</p><p>每天导师补贴40块钱吃饭，</p><p>另外还有一天20的工资，</p><p>虽然也很少，</p><p>但是啊</p><p>我实际每天平均工作时间不足2小时，</p><p>其他时间都在上自习，</p><p>我觉得挺好的，</p><p>也不知道这个现状能够维持多久。</p><p>今年夏天就有 一批学长学姐毕业了，</p><p>真的很羡慕，</p><p>原本我是非常想好好度过我人生中最后三年的学生时代，</p><p>但是现在这个状态和社畜的区别其实也不是很大。</p><p>最近了解了很多关于国企程序猿的东西，感觉不是我想要的生活，</p><p>虽然就工作作息时间来说，</p><p>非常吸引人啊。</p><p>总之，好好学习啊，毕业希望能找到满意的工作！</p>]]></content>
    
    
    <categories>
      
      <category>学习路上的一些记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-集合练习题（HashSet添加机制）</title>
    <link href="/2023/02/20/Java-%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88HashSet%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/02/20/Java-%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88HashSet%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-集合练习题（HashSet添加机制）"><a href="#Java-集合练习题（HashSet添加机制）" class="headerlink" title="Java-集合练习题（HashSet添加机制）"></a>Java-集合练习题（HashSet添加机制）</h1><ul><li>韩顺平Java视频中的练习题，坑挺多的，mark一下；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-type">int</span> id;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">//根据id和name属性重写了hashCode()和equals()</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;<br>        <span class="hljs-keyword">return</span> id == person.id &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(id, name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">practices06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;AA&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1002</span>, <span class="hljs-string">&quot;BB&quot;</span>);<br>        set.add(p1);<br>        set.add(p2);<br>        <span class="hljs-comment">//此时，set中有两个元素：</span><br>        <span class="hljs-comment">//1.索引hashCode(1001, &quot;AA&quot;)====&gt;p1&#123;1001, &quot;AA&quot;&#125;;</span><br>        <span class="hljs-comment">//2.索引hashCode(1002, &quot;BB&quot;)====&gt;p1&#123;1002, &quot;BB&quot;&#125;;</span><br>        p1.name = <span class="hljs-string">&quot;CC&quot;</span>;<br>        <span class="hljs-comment">//此时，set中的两个元素为：</span><br>        <span class="hljs-comment">//1.索引hashCode(1001, &quot;AA&quot;)====&gt;p1&#123;1001, &quot;CC&quot;&#125;;</span><br>        <span class="hljs-comment">//2.索引hashCode(1002, &quot;BB&quot;)====&gt;p2&#123;1002, &quot;BB&quot;&#125;;</span><br><br>        set.remove(p1);<br>        <span class="hljs-comment">//由于remove()方法删除时，是删除set中索引为hashCode(1001, &quot;CC&quot;)处的元素，由于该处没有元素，remove()没有删除任何元素；</span><br><br>        System.out.println(set);<br>        <span class="hljs-comment">//打印set中的两个元素：</span><br>        <span class="hljs-comment">//1.索引hashCode(1001, &quot;AA&quot;)====&gt;p1&#123;1001, &quot;CC&quot;&#125;;</span><br>        <span class="hljs-comment">//2.索引hashCode(1002, &quot;BB&quot;)====&gt;p2&#123;1002, &quot;BB&quot;&#125;;</span><br><br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;CC&quot;</span>));<br>        <span class="hljs-comment">//此时，set中的三个元素为：</span><br>        <span class="hljs-comment">//1.索引hashCode(1001, &quot;AA&quot;)====&gt;p1&#123;1001, &quot;CC&quot;&#125;;</span><br>        <span class="hljs-comment">//2.索引hashCode(1002, &quot;BB&quot;)====&gt;p2&#123;1002, &quot;BB&quot;&#125;;</span><br>        <span class="hljs-comment">//3.索引hashCode(1001, &quot;CC&quot;)====&gt;&#123;1001, &quot;CC&quot;&#125;;</span><br><br>        System.out.println(set);<br>        <span class="hljs-comment">//打印set中的三个元素：</span><br>        <span class="hljs-comment">//1.索引hashCode(1001, &quot;AA&quot;)====&gt;p1&#123;1001, &quot;CC&quot;&#125;;</span><br>        <span class="hljs-comment">//2.索引hashCode(1002, &quot;BB&quot;)====&gt;p2&#123;1002, &quot;BB&quot;&#125;;</span><br>        <span class="hljs-comment">//3.索引hashCode(1001, &quot;CC&quot;)====&gt;&#123;1001, &quot;CC&quot;&#125;;</span><br>        <br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;AA&quot;</span>));<br><span class="hljs-comment">//此时，set中的四个元素为：</span><br>        <span class="hljs-comment">//1.索引hashCode(1001, &quot;AA&quot;)====&gt;p1&#123;1001, &quot;CC&quot;&#125; ====&gt;&#123;1001, &quot;AA&quot;&#125;;</span><br>        <span class="hljs-comment">//2.索引hashCode(1002, &quot;BB&quot;)====&gt;p2&#123;1002, &quot;BB&quot;&#125;;</span><br>        <span class="hljs-comment">//3.索引hashCode(1001, &quot;CC&quot;)====&gt;&#123;1001, &quot;CC&quot;&#125;;</span><br>        <br>        System.out.println(set);<br>        <span class="hljs-comment">//打印set中的四个元素为：</span><br>        <span class="hljs-comment">//1.索引hashCode(1001, &quot;AA&quot;)====&gt;p1&#123;1001, &quot;CC&quot;&#125; ====&gt;&#123;1001, &quot;AA&quot;&#125;;</span><br>        <span class="hljs-comment">//2.索引hashCode(1002, &quot;BB&quot;)====&gt;p2&#123;1002, &quot;BB&quot;&#125;;</span><br>        <span class="hljs-comment">//3.索引hashCode(1001, &quot;CC&quot;)====&gt;&#123;1001, &quot;CC&quot;&#125;;</span><br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划-LeetCode_T376（里面还有贪心思路的题解！！）</title>
    <link href="/2023/02/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-LeetCode_T376/"/>
    <url>/2023/02/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-LeetCode_T376/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划-LeetCode-T376"><a href="#动态规划-LeetCode-T376" class="headerlink" title="动态规划_LeetCode_T376"></a>动态规划_LeetCode_T376</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/wiggle-subsequence">https://leetcode.cn/problems/wiggle-subsequence</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>这道题，说实话，我没有写出来（动态规划太难了啊T-T），然后看那个代码随想录的题解，一开始看到下图时，顿时有了思路，并写了出来，这个思路还是可以的，赞。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201124174327597.png"></p><ul><li>然后听说这叫贪心思想；</li><li>最后看了LeetCode题解区的几个大佬，看到了一个写得比较清晰的动态规划，记录一下；</li></ul><p><img src="https://thumbnail1.baidupcs.com/thumbnail/28f32252dt70b55ee61ebe58b54c928c?fid=1611021205-250528-22122234599791&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Vf0I9qrXr6pwAiBMWZS1p79mOJc=&expires=8h&chkbd=0&chkv=0&dp-logid=606912066208099&dp-callid=0&time=1676797200&size=c1280_u720&quality=90&vuk=1611021205&ft=image&autopolicy=1"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//记录最长子序列长度</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//记录状态：升序 =&gt; 1, 降序 =&gt; 0, 持平 =&gt; -1</span><br><br>        <span class="hljs-comment">//这一波操作是：</span><br>        <span class="hljs-comment">//1.判断第一次是升序还是降序;</span><br>        <span class="hljs-comment">//2.防止一开始都是相同的值,例如0 0 0 0 1；</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != num) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] - num &gt; <span class="hljs-number">0</span>)<br>                    flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == -<span class="hljs-number">1</span>)<span class="hljs-comment">//如果整个序列都是同一个值</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//根据图1的思想，连续多个单调升/降的值仅计算最后一个升/降</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] - nums[i-<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                count++;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] - nums[i-<span class="hljs-number">1</span>] &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                count++;<br>                flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态递归解法"><a href="#动态递归解法" class="headerlink" title="动态递归解法"></a>动态递归解法</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//1.确定dp数组以及下标的含义</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">//dp[i][0]: 表示到当前位置nums[i], 以 降序 结尾的摆动数组的最长子序列的长度；</span><br>        <span class="hljs-comment">//dp[i][1]: 表示到当前位置nums[i], 以 升序 结尾的摆动数组的最长子序列的长度；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i-<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//当前元素与上一个值是升序的</span><br>                dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>                dp[i][<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<span class="hljs-comment">//前一次降 + 1</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//当前元素与上一个值是降序的</span><br>                dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<span class="hljs-comment">//前一次升 + 1</span><br>                dp[i][<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//当前元素与上一个值是持平的</span><br>                dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//与上一次保持一致</span><br>                dp[i][<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[nums.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[nums.length-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-经典同分支去重（flag标记数组）</title>
    <link href="/2023/02/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%88%86%E6%94%AF%E5%8E%BB%E9%87%8D%EF%BC%88flag%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <url>/2023/02/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%88%86%E6%94%AF%E5%8E%BB%E9%87%8D%EF%BC%88flag%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-经典同分支去重（flag标记数组）"><a href="#回溯算法-经典同分支去重（flag标记数组）" class="headerlink" title="回溯算法-经典同分支去重（flag标记数组）"></a>回溯算法-经典同分支去重（flag标记数组）</h3><h4 id="LeetCode参考题目："><a href="#LeetCode参考题目：" class="headerlink" title="LeetCode参考题目："></a>LeetCode参考题目：</h4><ul><li>LeetCode_46</li></ul><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/permutations">https://leetcode.cn/problems/permutations</a></p><p><strong>flag标记数组可以用于同层去重也可以用于同分支去重！！！</strong></p><p><strong>下面是去重的写法</strong></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ansList;<br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; cur_list;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index,<span class="hljs-type">int</span>[] flag)</span>&#123;<br>        <span class="hljs-comment">//关键点：</span><br>        <span class="hljs-comment">//1.回溯算法中，for循环是同层遍历，回溯递归是遍历所有分支；</span><br>        <span class="hljs-keyword">if</span>(index == nums.length)&#123;<br>            ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur_list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(flag[nums[i] + <span class="hljs-number">10</span>] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            cur_list.add(nums[i]);<br>            flag[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//题目给出nums[i]的范围是[-10, 10],因此加上10，避免下标越界；</span><br>        <span class="hljs-comment">//2.本题需要同分支去重，因此需要将标记数组传给回溯递归函数；</span><br>            backTrack(nums, index+<span class="hljs-number">1</span>, flag);<br>            <span class="hljs-comment">//3.每次回溯返回是，flag数组也需要&quot;撤销&quot;操作;</span><br>            flag[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-number">0</span>;<br>            cur_list.remove(cur_list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur_list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-type">int</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">25</span>];<br><br>        backTrack(nums, <span class="hljs-number">0</span>, flag);<br><br>        <span class="hljs-keyword">return</span> ansList;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法-解题思路</title>
    <link href="/2023/02/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <url>/2023/02/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="贪心算法-解题思路"><a href="#贪心算法-解题思路" class="headerlink" title="贪心算法-解题思路"></a>贪心算法-解题思路</h3><ul><li><p>没什么固定的套路，一来说就是，常识性推导+举反例。</p></li><li><p>能够从 局部最优 推出 全局最优即可。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习路线（ChatGPT版）</title>
    <link href="/2023/02/17/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88ChatGPT%E7%89%88%EF%BC%89/"/>
    <url>/2023/02/17/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88ChatGPT%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Java学习路线（ChatGPT版）"><a href="#Java学习路线（ChatGPT版）" class="headerlink" title="Java学习路线（ChatGPT版）"></a>Java学习路线（ChatGPT版）</h1><h3 id="第一阶段：复习Java基础（2个月左右）"><a href="#第一阶段：复习Java基础（2个月左右）" class="headerlink" title="第一阶段：复习Java基础（2个月左右）"></a>第一阶段：复习Java基础（2个月左右）</h3><ul><li>复习Java语法基础，包括数据类型、运算符、表达式、控制语句等；<em><strong>（已完成）</strong></em></li><li>复习面向对象编程的相关知识，包括类和对象、继承、多态、接口等；<em><strong>（已完成）</strong></em></li><li>复习异常处理、集合框架、IO流等常用的Java API；<em><strong>（进行中）</strong></em></li><li>复习常用的设计模式。</li></ul><h3 id="第二阶段：深入Java进阶知识（4个月左右）"><a href="#第二阶段：深入Java进阶知识（4个月左右）" class="headerlink" title="第二阶段：深入Java进阶知识（4个月左右）"></a>第二阶段：深入Java进阶知识（4个月左右）</h3><ul><li>深入学习Java多线程编程，包括线程的创建与管理、线程同步与互斥、线程间通信等；</li><li>深入学习Java网络编程，包括Socket编程、HTTP协议、Web应用等；</li><li>深入学习Java虚拟机（JVM）的原理与应用；</li><li>深入学习Java内存模型、垃圾回收算法等。</li></ul><h3 id="第三阶段：Java框架学习（4个月左右）"><a href="#第三阶段：Java框架学习（4个月左右）" class="headerlink" title="第三阶段：Java框架学习（4个月左右）"></a>第三阶段：Java框架学习（4个月左右）</h3><ul><li>学习Spring框架的基础知识和原理；</li><li>学习Spring MVC和Spring Boot框架的应用；</li><li>学习MyBatis框架的应用和原理。</li></ul><h3 id="第四阶段：Java项目实战（4个月左右）"><a href="#第四阶段：Java项目实战（4个月左右）" class="headerlink" title="第四阶段：Java项目实战（4个月左右）"></a>第四阶段：Java项目实战（4个月左右）</h3><ul><li>实践一个完整的Java Web项目，例如电商平台、博客系统等；</li><li>学习项目管理、版本控制等工具的使用；<em><strong>（进行中）</strong></em></li><li>学习常用的性能优化手段。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习路线（ChatGPT版）</title>
    <link href="/2023/02/17/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88ChatGPT%E7%89%88%EF%BC%89/"/>
    <url>/2023/02/17/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88ChatGPT%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习路线（ChatGPT版）"><a href="#MySQL学习路线（ChatGPT版）" class="headerlink" title="MySQL学习路线（ChatGPT版）"></a>MySQL学习路线（ChatGPT版）</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>掌握 SQL 基本语法和常用函数</li><li>学会使用 SQL 进行数据查询和数据分析</li><li>能够使用 SQL 对数据进行增、删、改操作</li><li>了解 MySQL 数据库的设计和优化原则</li></ul><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li>B 站黑马程序员 SQL 视频课程：<a href="https://www.bilibili.com/video/BV1YJ411P7dU">https://www.bilibili.com/video/BV1YJ411P7dU</a></li><li>MySQL 官方文档：<a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></li></ul><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><h3 id="第-1-2-周：SQL-基础知识"><a href="#第-1-2-周：SQL-基础知识" class="headerlink" title="第 1-2 周：SQL 基础知识"></a>第 1-2 周：SQL 基础知识</h3><ul><li>观看黑马程序员 SQL 视频课程第 1-11 讲</li><li>学习 SQL 基本语法、查询语句、条件查询、排序查询、分组查询等基础知识</li></ul><h3 id="第-3-4-周：SQL-函数和操作"><a href="#第-3-4-周：SQL-函数和操作" class="headerlink" title="第 3-4 周：SQL 函数和操作"></a>第 3-4 周：SQL 函数和操作</h3><ul><li>观看黑马程序员 SQL 视频课程第 12-20 讲</li><li>学习 SQL 中常用的函数，如字符串函数、数学函数、日期函数等</li><li>学习 SQL 中的增、删、改操作</li></ul><h3 id="第-5-6-周：高级-SQL-操作和数据分析"><a href="#第-5-6-周：高级-SQL-操作和数据分析" class="headerlink" title="第 5-6 周：高级 SQL 操作和数据分析"></a>第 5-6 周：高级 SQL 操作和数据分析</h3><ul><li>观看黑马程序员 SQL 视频课程第 21-31 讲</li><li>学习 SQL 中的高级操作，如子查询、联合查询、事务、视图等</li><li>学习如何使用 SQL 进行数据分析，如聚合统计、数据透视等</li></ul><h3 id="第-7-8-周：MySQL-数据库设计和优化"><a href="#第-7-8-周：MySQL-数据库设计和优化" class="headerlink" title="第 7-8 周：MySQL 数据库设计和优化"></a>第 7-8 周：MySQL 数据库设计和优化</h3><ul><li>观看黑马程序员 SQL 视频课程第 32-38 讲</li><li>学习 MySQL 数据库的设计原则和优化方法</li><li>了解 MySQL 数据库的常用工具和技巧，如索引优化、存储过程、触发器等</li></ul><h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ul><li>每天至少花 2 小时学习 SQL，建议在学习期间尽量集中注意力，减少干扰和分心。</li><li>在学习过程中，尝试使用 SQL 对实际数据进行操作和查询，以加深印象和提高实战能力。</li><li>学习过程中，可以结合官方文档和其他 SQL 学习资源，以更好地理解和掌握 SQL 知识。</li><li>如果时间允许，建议参加在线课程或者线下培训，与老师和同学交流，提高学习效果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-LeetCode_T332（回溯算法章节暂时告一段落）</title>
    <link href="/2023/02/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-LeetCode_T332%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82%E6%9A%82%E6%97%B6%E5%91%8A%E4%B8%80%E6%AE%B5%E8%90%BD%EF%BC%89/"/>
    <url>/2023/02/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-LeetCode_T332%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%AB%A0%E8%8A%82%E6%9A%82%E6%97%B6%E5%91%8A%E4%B8%80%E6%AE%B5%E8%90%BD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-LeetCode-T332（回溯算法章节暂时告一段落）"><a href="#回溯算法-LeetCode-T332（回溯算法章节暂时告一段落）" class="headerlink" title="回溯算法-LeetCode_T332（回溯算法章节暂时告一段落）"></a>回溯算法-LeetCode_T332（回溯算法章节暂时告一段落）</h3><ul><li>题目描述</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html">给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。<br><br>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。<br><br>例如，行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小，排序更靠前。<br>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。<br><br>示例 1：<br>输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]<br>输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]<br><br>示例 2：<br>输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]<br>输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]<br>解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode.cn/problems/reconstruct-itinerary<br></code></pre></td></tr></table></figure><p><strong>今天是2023年02月16日</strong></p><p><strong>LeetCode上刷到的第一道Hard题，mark一下</strong></p><p><strong>代码随想录中回溯算法章节还剩下3到Hard题，希望能够通过多刷题，终有一天我能够独立写出来的！</strong></p><p><strong>先开始下一章节的学习，冲！</strong></p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习-SQL语言</title>
    <link href="/2023/02/16/MySQL-SQL%E8%AF%AD%E8%A8%80/"/>
    <url>/2023/02/16/MySQL-SQL%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习–SQL语言"><a href="#MySQL学习–SQL语言" class="headerlink" title="MySQL学习–SQL语言"></a>MySQL学习–SQL语言</h1><h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h2><ul><li>1.SQL语句可以单行或多行书写，以分号结尾；</li><li>2.SQL语句可以使用空格&#x2F;缩进来增强语句的可读性；</li><li>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写；</li><li>4.注释：<ul><li>单行注释：– 注释内容 或 # 注释内容<strong>（MySQL特有）</strong></li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul><h2 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h2><ul><li>主要用来定义数据库对象（数据库、视图、索引、表、字段等）</li></ul><h3 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h3><h4 id="1）查询"><a href="#1）查询" class="headerlink" title="1）查询"></a>1）查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询所有的数据库</span><br><span class="hljs-keyword">SHOW</span> DATABASES;<br><br><span class="hljs-comment">-- 查询当前数据库</span><br><span class="hljs-keyword">SELECT</span> DATABASE();<br></code></pre></td></tr></table></figure><h4 id="2）创建"><a href="#2）创建" class="headerlink" title="2）创建"></a>2）创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建数据库</span><br><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名 [<span class="hljs-keyword">DEFAULT</span> CHARSET 字符集] [<span class="hljs-keyword">COLLATE</span> 排序规则];<br><span class="hljs-comment">-- [] 中的选项是可选的</span><br><span class="hljs-comment">-- IF NOT EXISTS表示如果该数据库不存在则创建；</span><br><br><span class="hljs-comment">-- 例如：1.创建一个名为 DATABASE_SEA_1 的数据库的SQL语句如下：</span><br><span class="hljs-keyword">CREATE</span> DATABASE DATABASE_SEA_1;<br><br><span class="hljs-comment">-- 2.加入可选项IF NOT EXISTS，当数据库中已经有该名称的数据库时不进行创建；反之，则创建；</span><br><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> DATABASE_SEA_1;<br><br><span class="hljs-comment">-- 3.加入可选项DEFAULT CHARSET 字符集，指定默认字符集为UTF8；</span><br><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> DATABASE_SEA_1 <span class="hljs-keyword">DEFAULT</span> CHARSET UTF8;<br></code></pre></td></tr></table></figure><h4 id="3）删除"><a href="#3）删除" class="headerlink" title="3）删除"></a>3）删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除数据库</span><br><span class="hljs-keyword">DROP</span> DATABASE [IF <span class="hljs-keyword">EXISTS</span>] 数据库名;<br></code></pre></td></tr></table></figure><h4 id="4）使用"><a href="#4）使用" class="headerlink" title="4）使用"></a>4）使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 进入mysql</span><br>mysql <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p # 然后根据提示，输入root用户的密码即可；<br><br><span class="hljs-comment">-- 使用数据库</span><br>USE 数据库名;<br><br><span class="hljs-comment">-- 查看当前正在使用的数据库</span><br><span class="hljs-keyword">SELECT</span> DATABASE();<br></code></pre></td></tr></table></figure><h3 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2.表操作"></a>2.表操作</h3><h4 id="1）查询-1"><a href="#1）查询-1" class="headerlink" title="1）查询"></a>1）查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询当前数据库所有表</span><br><span class="hljs-keyword">SHOW</span> TABLES;<br><br><span class="hljs-comment">-- 查询表结构</span><br><span class="hljs-keyword">DESC</span> 表名;<br><br><span class="hljs-comment">-- 查询指定表的建表语句</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h4 id="2）创建-1"><a href="#2）创建-1" class="headerlink" title="2）创建"></a>2）创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型[COMMENT <span class="hljs-string">&#x27;字段1注释&#x27;</span>],<br>    字段<span class="hljs-number">2</span> 字段<span class="hljs-number">2</span>类型[COMMENT <span class="hljs-string">&#x27;字段2注释&#x27;</span>],<br>    字段<span class="hljs-number">2</span> 字段<span class="hljs-number">3</span>类型[COMMENT <span class="hljs-string">&#x27;字段3注释&#x27;</span>],<br>    ...<br>    字段N 字段N类型[COMMENT <span class="hljs-string">&#x27;字段N注释&#x27;</span>]<br>)[COMMENT <span class="hljs-string">&#x27;表注释&#x27;</span>];<br><br><span class="hljs-comment">-- 例如：1.在数据库中DATABASE_SEA_1创建用户表USER；</span><br>USE DATABASE_SEA_1;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span>(<br>id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    gender <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>)COMMENT <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="3）数据类型"><a href="#3）数据类型" class="headerlink" title="3）数据类型"></a>3）数据类型</h4><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a><strong>数值类型</strong></h5><table><thead><tr><th>类型</th><th>大小</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 byte</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2  bytes</td><td>(-32768，32767)</td><td>(0，65535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3  bytes</td><td>(-8388608，8388607)</td><td>(0，16777215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4  bytes</td><td>(-2147483648，2147483647)</td><td>(0，4294967295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8  bytes</td><td>(-2^63，2^63-1)</td><td>(0，2^64-1)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4  bytes</td><td>(-3.402823466 E+38，3.402823466351  E+38)</td><td>0 和 (1.175494351  E-38，3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8  bytes</td><td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td><td>0 和  (2.2250738585072014 E-308，1.7976931348623157 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于M(精度)和D(标度)的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定点数)</td></tr></tbody></table><p><strong>注意：</strong></p><p>​<strong>1.DECIMAL类型中的精度（M）和标度（D）的含义：例如123.45的精度M&#x3D;5(整个数字的长度), 标度D&#x3D;2(小数位数)；例如score double(4, 1)可以指定考试成绩字段score最大长度为4，小数位数为1位，如100.0,90.5；</strong></p><p>​<strong>2.使用无符号范围，例如年龄age不可能为负数，只需age TINYINT UNSIGNED即可。</strong></p><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a><strong>字符串类型</strong></h5><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p><strong>注意：</strong></p><p>​<strong>1.BLOB一般是二进制数据，TEXT一般是文本数据；</strong></p><p>​<strong>2.CHAR表示定长字符串，即使只存放了1个字符也会占用指定大小的空间 &#x3D;&#x3D;&gt; 性能好；</strong></p><p>​<strong>3.VARCHAR表示变长字符串，根据实际存放的字符数指定该数据存储空间大小 &#x3D;&#x3D;&gt; 需要计算，性能较差；</strong></p><h5 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a><strong>日期时间类型</strong></h5><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01 至  9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59 至  838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01 至 <strong>2038</strong>-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><p><strong>注意：</strong></p><p>​<strong>1.TIMESTAMP类型只能表示到2038年。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/* 案例 设计一张员工信息表，要求如下：</span><br><span class="hljs-comment">1.编号（纯数字）</span><br><span class="hljs-comment">2.员工工号（字符串类型，长度不超过10）</span><br><span class="hljs-comment">3.员工姓名（字符串类型，长度不超过10）</span><br><span class="hljs-comment">4.性别（男/女，存储一个汉字）</span><br><span class="hljs-comment">5.年龄（正常年龄，不可能为负数）</span><br><span class="hljs-comment">6.身份证号（二代身份证号均为18位，身份证中有X字符）</span><br><span class="hljs-comment">7.入职时间（取值年月日即可）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employee(<br>ID <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;编号&#x27;</span>,<br>empl_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) COMMENT <span class="hljs-string">&#x27;员工工号&#x27;</span>,<br>empl_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) COMMENT <span class="hljs-string">&#x27;员工姓名&#x27;</span>,<br>gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) COMMENT <span class="hljs-string">&#x27;性别&#x27;</span>,<br>age TINYINT UNSIGNED COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>identify_id <span class="hljs-type">CHAR</span>(<span class="hljs-number">18</span>) COMMENT <span class="hljs-string">&#x27;身份证号&#x27;</span>,<br>entry_time <span class="hljs-type">DATE</span> COMMENT <span class="hljs-string">&#x27;入职时间&#x27;</span><br>)COMMENT <span class="hljs-string">&#x27;员工信息表&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="4）修改"><a href="#4）修改" class="headerlink" title="4）修改"></a>4）修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 添加字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 字段类型(长度) [COMMENT 注释] [约束];<br><br><span class="hljs-comment">-- 修改字段数据类型</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 新的数据类型(长度);<br><br><span class="hljs-comment">-- 修改字段名和字段类型</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];<br><br><span class="hljs-comment">-- 删除字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 字段名;<br><br><span class="hljs-comment">-- 修改表名</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 RENAME <span class="hljs-keyword">TO</span> 新的表名;<br></code></pre></td></tr></table></figure><h4 id="5）删除"><a href="#5）删除" class="headerlink" title="5）删除"></a>5）删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] 表名;<br><br><span class="hljs-comment">-- 删除指定表，并重新创建该表；（相当于清空表）</span><br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h2 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h2><ul><li>主要用来对数据库表中的数据进行增删改；</li></ul><h3 id="添加数据（INSERT）"><a href="#添加数据（INSERT）" class="headerlink" title="添加数据（INSERT）"></a>添加数据（INSERT）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 添加数据</span><br><br><span class="hljs-comment">-- 给指定字段添加数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, 值<span class="hljs-number">3</span>, ...);<br><br><span class="hljs-comment">-- 给全部字段添加数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, 值<span class="hljs-number">3</span>, ...);<br><br><span class="hljs-comment">-- 批量添加数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, 值<span class="hljs-number">3</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 指定的字段顺序需要与值的顺序是一一对应的</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee (empl_id, empl_name, gender, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, &quot;test&quot;, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><ul><li>字符串和日期型数据应该包含在引号中；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 字符串和日期型数据应该包含在引号中</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee (empl_id, empl_name, gender, age, entry_time) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, &quot;test&quot;, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;2023-02-19&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>插入的数据大小，应该在字段的规定范围内；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入的数据大小，应该在字段的规定范围内</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee (empl_id, empl_name, gender, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, &quot;test&quot;, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">-18</span>);<br><br><span class="hljs-comment">/*报错如下</span><br><span class="hljs-comment">INSERT INTO employee (empl_id, empl_name, gender, age) VALUES (1, &quot;test&quot;, &#x27;男&#x27;, -18)</span><br><span class="hljs-comment">&gt; 1264 - Out of range value for column &#x27;age&#x27; at row 1</span><br><span class="hljs-comment">&gt; 时间: 0.001s</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="修改数据（UPDATE）"><a href="#修改数据（UPDATE）" class="headerlink" title="修改数据（UPDATE）"></a>修改数据（UPDATE）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改数据</span><br><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span>, ...[<span class="hljs-keyword">WHERE</span> 条件];<br><br><span class="hljs-comment">-- 例如：</span><br><span class="hljs-comment">-- 修改18岁的员工的性别和薪资</span><br><span class="hljs-keyword">UPDATE</span> employee <span class="hljs-keyword">SET</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>, salary_num <span class="hljs-operator">=</span> <span class="hljs-number">10000</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br><span class="hljs-comment">-- 设置所有员工的身份证号</span><br><span class="hljs-keyword">UPDATE</span> employee <span class="hljs-keyword">SET</span> identify_id <span class="hljs-operator">=</span> <span class="hljs-number">360735</span>;<br><span class="hljs-comment">-- 设置所有员工的入职日期</span><br><span class="hljs-keyword">UPDATE</span> employee <span class="hljs-keyword">SET</span> entry_time <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2008-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据（DELETE）"><a href="#删除数据（DELETE）" class="headerlink" title="删除数据（DELETE）"></a>删除数据（DELETE）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除数据</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 [<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>DELETE语句的条件是可选项，若没有，则会删除整张表的所有数据；</li><li>DELETE不能删除某一个字段的值（可以使用UPDATE语句实现）；</li></ul><h2 id="数据查询语言（DQL）"><a href="#数据查询语言（DQL）" class="headerlink" title="数据查询语言（DQL）"></a>数据查询语言（DQL）</h2><ul><li>主要用来查询数据库中表的记录；</li></ul><h2 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h2><ul><li>主要用来创建数据库用户和控制数据库的访问权限；</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习-数据模型</title>
    <link href="/2023/02/16/MySQL-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/02/16/MySQL-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习–数据模型"><a href="#MySQL学习–数据模型" class="headerlink" title="MySQL学习–数据模型"></a>MySQL学习–数据模型</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><ul><li><p>英文简称：RDBMS；</p></li><li><p>概念：建立在关系模型基础上，由<strong>多张相互连接的二维表</strong>组成的数据库。</p></li><li><p>特点：</p><ul><li>使用表结构存储数据，格式统一，便于维护；</li><li>使用SQL语言操作数据，标准统一，使用方便；</li></ul></li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><ul><li>角色：<ul><li>客户端</li><li>DBMS</li><li>数据库</li><li>数据表</li><li>记录</li><li>MySQL数据库服务器</li></ul></li><li>关系<ul><li>计算机安装了MySQL后，就成为了<strong>MySQL数据库服务器</strong>；</li><li><strong>客户端</strong>通过连接<strong>DBMS</strong>来管理<strong>数据库</strong>；</li><li>客户端使用<strong>SQL语句</strong>通过DBMS来：<ul><li>创建多个数据库；</li><li>在数据库中创建多张<strong>数据表</strong>；</li><li>在表中增加多条<strong>记录</strong>；</li><li>等等；</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习-将基本数据类型封装成包装类的好处</title>
    <link href="/2023/02/16/Java%E5%AD%A6%E4%B9%A0-%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E6%88%90%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <url>/2023/02/16/Java%E5%AD%A6%E4%B9%A0-%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E6%88%90%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Java学习-将基本数据类型封装成包装类的好处"><a href="#Java学习-将基本数据类型封装成包装类的好处" class="headerlink" title="Java学习-将基本数据类型封装成包装类的好处"></a>Java学习-将基本数据类型封装成包装类的好处</h2><ul><li>1.可以赋null值，有些地方需要赋null，但是基本数据类型不能赋null；</li></ul><ul><li><pre><code class="hljs"> 2.有缓存机制。例如Integer缓存了-128~127区间的数值；</code></pre></li><li><pre><code class="hljs"> 3.集合中只能存放Object及其子类 类型的数据，不能存放基本数据类型；</code></pre></li><li><pre><code class="hljs"> 可能还有其它的；</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
      <category>Wrapper类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Wrapper类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-transient关键字</title>
    <link href="/2023/02/16/Java-transient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/02/16/Java-transient%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-transient关键字"><a href="#Java-transient关键字" class="headerlink" title="Java-transient关键字"></a>Java-transient关键字</h1><ul><li><p>1.在 Java 中，<code>transient</code> 是一个关键字，用于修饰类的成员变量，表示该变量不参与序列化过程。</p></li><li><p>2.在 Java 中，当需要将一个对象序列化为字节流并在网络或者文件中传输时，会使用 <code>ObjectOutputStream</code> 进行序列化操作。而 <code>transient</code> 关键字可以用来控制序列化过程中哪些成员变量需要被序列化，哪些成员变量不需要被序列化。</p></li><li><p>3.具体来说，被 <code>transient</code> 修饰的变量，当对象被序列化时，这个变量的值不会被写入到序列化输出流中；而当对象被反序列化时，这个变量的值会被默认初始化，也就是赋予该变量类型的默认值。</p></li><li><p>4.使用 <code>transient</code> 的场景通常是当某个成员变量不应该被序列化时，例如一些敏感信息、临时计算结果等，这些信息不需要被存储在序列化的字节流中。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习-MySQL介绍</title>
    <link href="/2023/02/14/MySQL-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/02/14/MySQL-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习-MySQL介绍"><a href="#MySQL学习-MySQL介绍" class="headerlink" title="MySQL学习-MySQL介绍"></a>MySQL学习-MySQL介绍</h1><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><p>Database，简称DB；</p></li><li><p>存储数据的仓库，数据是有组织的进行存储；</p></li></ul><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><ul><li><p>Database Management System，简称DBMS；</p></li><li><p>操纵和管理数据库的大型软件；</p></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>Structured Query Language，简称SQL；</li><li>操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准；</li></ul><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul><li><p><strong>程序员</strong> 通过 <strong>SQL</strong> 操作 <strong>数据库管理系统</strong>；</p></li><li><p>通过 <strong>数据库管理系统</strong> 来操作 <strong>数据库以及数据库中的数据</strong>；</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-经典同层去重（flag标记数组）</title>
    <link href="/2023/02/14/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88flag%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <url>/2023/02/14/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88flag%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-经典同层去重（flag标记数组）"><a href="#回溯算法-经典同层去重（flag标记数组）" class="headerlink" title="回溯算法-经典同层去重（flag标记数组）"></a>回溯算法-经典同层去重（flag标记数组）</h3><h4 id="LeetCode参考题目："><a href="#LeetCode参考题目：" class="headerlink" title="LeetCode参考题目："></a>LeetCode参考题目：</h4><ul><li>LeetCode_491</li></ul><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/non-decreasing-subsequences">https://leetcode.cn/problems/non-decreasing-subsequences</a></p><p><strong>flag标记数组去重也可以解决LeetCode_40和LeetCode_90中同层去重问题！！所以，尽量使用这个进行同层去重！！！</strong></p><p><strong>下面是去重的写法</strong></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ansList;<br>    List&lt;Integer&gt; cur_s;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index == nums.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">205</span>];<span class="hljs-comment">//标记数组，同层遍历时，前面已经使用过的数字，不能在使用了！</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>((cur_s.size()&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; cur_s.get(cur_s.size()-<span class="hljs-number">1</span>)) || flag[nums[i] +<span class="hljs-number">100</span>] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            cur_s.add(nums[i]);<br>            <span class="hljs-comment">//使用过的数字就标记为1，由于nums[i]的范围在【-100，100】之间，因此需要加上100，避免下标为负数</span><br>            flag[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">if</span>(cur_s.size() &gt;= <span class="hljs-number">2</span>)<br>                ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur_s));<br><br>            backTrack(nums, i+<span class="hljs-number">1</span>);<br><br>            cur_s.remove(cur_s.size()-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur_s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        backTrack(nums, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ansList;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合框架体系整理（整理完毕！！）</title>
    <link href="/2023/02/14/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB/"/>
    <url>/2023/02/14/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h1><h2 id="Collection-单列集合"><a href="#Collection-单列集合" class="headerlink" title="Collection  (单列集合)"></a>Collection  (单列集合)</h2><h3 id="Collection接口实现类的特点"><a href="#Collection接口实现类的特点" class="headerlink" title="Collection接口实现类的特点"></a>Collection接口实现类的特点</h3><ul><li>1.可以存放多个Object类型的元素；</li><li>2.有些可以存放重复元素，有些不行；</li><li>3.有些是有序的（List），有些不是有序的（Set）；</li><li>4.没有直接的实现子类，是通过实现它的子接口Set和List实现的；</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li>1.List接口是Collection接口的子接口，特点：<ul><li>1)List集合类中的元素有序，即添加顺序和取出顺序一直，且元素可以重复；</li><li>2)List集合类中的元素支持索引，例如list.get(index)，返回的是集合中的第index+1个元素;</li></ul></li><li>2.遍历方式<ul><li>1)Iterator</li><li>2)增强for</li><li>3)普通for（即支持索引）</li></ul></li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList *"></a>ArrayList *</h4><ul><li>1.List接口的实现类；</li><li>2.可以存放任意类型的数据，包括null；</li><li>3.底层数据存储是由数组实现的；</li><li>4.基本等同于Vector，但是它线程不安全 &#x3D;&gt; 执行效率（源码中没有使用synchronized关键字修饰）；</li><li>5.在多线程情况下，不建议使用ArrayList；</li><li>6.扩容机制<ul><li>1）ArrayList维护了一个Object类型的数组elementData;</li><li>2）创建ArrayList对象时：<ul><li>如果使用的是无参构造器，则初始elementData数组容量为0，第一次添加元素，则扩容elementData数组容量为<strong>10</strong>，如需再次扩容，则扩容原elementData数组容量的<strong>1.5倍</strong>；</li><li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如需再次扩容，则扩容原elementData数组容量的<strong>1.5倍</strong>；</li></ul></li></ul></li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li><p>1.List接口的实现类</p></li><li><p>2.LinkedList底层实现了双向链表和双端队列的特点：</p><ul><li>1）每个节点都是Node对象；</li><li>2）底层维护了first，last，分别指向链表的首、尾节点；</li><li>3）节点内部维护了prev，next，item三个属性，prev指向前一个节点，next指向后一个节点，实现双向链表；</li></ul></li><li><p>3.可以添加任意类型的元素，包括null，且可以重复；</p></li><li><p>4.线程不安全，没有同步；</p></li><li><p>5.添加和删除操作效率较高（链表的优势）,不涉及到扩容问题；</p></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li><p>1.实现了List接口，并且继承了ArrayList类；</p></li><li><p>2.底层和ArrayList一样维护了一个Object类型的数组，elementData；</p></li><li><p>3.Vector支持线程同步，即线程安全，Vector类的操作方法（如setXXX()，getXXX()方法）带有synchronized关键字修饰；</p></li><li><p>4.扩容机制</p><ul><li><p>创建ArrayList对象时：</p><ul><li>如果使用的是无参构造器，则初始elementData数组容量为0，第一次添加元素，则扩容elementData数组容量为<strong>10</strong>，如需再次扩容，则扩容原elementData数组容量的<strong>2倍</strong>；</li><li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如需再次扩容，则扩容原elementData数组容量的<strong>2倍</strong>；</li></ul></li></ul></li></ul><h4 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h4><table><thead><tr><th></th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，链表直接追加</td><td>较低</td></tr></tbody></table><p><strong>上述是比较常用的实现子类，还有很多其他的实现子类；</strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>1.无序（添加和取出顺序不一致），且没有索引（例如：不能使用普通for进行遍历）；<ul><li>添加的顺序与取出顺序不一致，<strong>但是取出的顺序是固定的；</strong></li></ul></li><li>2.不允许有重复元素，因此Set中最多包含一个null值；</li><li>3.JDK API中Set接口的实现类有：<ul><li>HashSet</li><li>TreeSet</li><li>还有很多其他实现类和子接口；</li></ul></li><li>4.遍历方式<ul><li>1)Iterator</li><li>2)增强for</li><li><strong>3)不能使用普通for遍历（即不支持索引）</strong></li></ul></li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet *"></a>HashSet *</h4><ul><li><p>1.Set接口的实现类；</p></li><li><p>2.HashSet底层实现实际上是一个HashMap；</p></li><li><p>3.不能有重复元素（Set接口的实现类），可以存放null值，但是只能存放一个；</p></li><li><p>4.HashSet不保证元素有序，取决于hash后的索引结果；</p></li><li><p>5.<strong>低层扩容机制</strong>，底层是一个HashMap &#x3D;&gt; <strong>数组+链表+红黑树</strong></p><ul><li><p><strong>HashSet与HashMap的扩容机制不一样的地方：</strong></p><ul><li><strong>HashSet在add元素时，传入的key是待添加元素，而value是一个常量值，遍历HashSet时，HashSet的迭代器返回的是keySet的迭代器，因此仅遍历key；</strong></li><li><strong>HashMap在add元素时，传入的是一个程序员自定义的键值对；</strong></li></ul></li><li><p>1）添加一个元素时，先通过hash算法得到hash值，通过<strong>某个</strong>算法转成索引值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//hash()方法，获得hash值</span><br><span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//“某个算法”即i = (n - 1) &amp; hash  实现：hash值 ==&gt; table的索引值</span><br>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]<br></code></pre></td></tr></table></figure></li><li><p>2）找到存储数据表table，检查该索引位置是否已经存放有元素：</p><ul><li>若没有元素，直接加入；</li><li>若有元素，调用equals()方法进行比较，如果相同则放弃添加，如果不相同则添加到链表最后；</li></ul></li><li><p>3）在Java8中，如果一条链表的元素个数 &gt;&#x3D; TREEIFY_THRESHOLD值（默认值是8），并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY值(默认值是64)时，会将该链表转化为一颗红黑树；</p></li><li><p>4）若仅该链表元素个数 &gt; 8，而table的大小仍 &lt; 64时，先对table数组进行扩容；</p><ul><li><strong>table数组扩容机制</strong>：</li><li>（1）HashMap初始化时设定了一个loadFactor值，默认初始为0.75；</li><li>（2）table的容量默认初始为16；</li><li>（3）当table中的元素个数(包括链表中的节点) &gt; 阈值（即threshold值，此时为16 * 0.75&#x3D;12）时，table容量扩大为原来的2倍，阈值threshold为 loadFactor * table的容量；</li><li>（4）数组扩容后，元素的位置也会进行重新分布(具体见源码中的resize()方法)；</li></ul></li></ul></li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li>1.HashSet的子类；</li><li>2.底层是一个<strong>LinkedHashMap</strong>（HashMap的子类），底层维护了一个<strong>数组+双向链表</strong>；</li><li>3.根据元素的<strong>hashCode值</strong>来决定元素的存储位置，同时使用链表维护元素的次序，即<strong>加入顺序和取出顺序一致</strong>；</li><li>4.不允许插入重复元素；</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li>1.Set接口的实现类；</li><li>2.底层是TreeMap；</li><li>3.通过构造函数创建TreeSet对象时，可以传入一个比较器进行排序：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSet01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//TreeSet源码分析</span><br><br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>();<span class="hljs-comment">//无参构造器，不排序</span><br><br>        treeSet.add(<span class="hljs-string">&quot;a345bc&quot;</span>);<br>        treeSet.add(<span class="hljs-string">&quot;46bsd&quot;</span>);<br>        treeSet.add(<span class="hljs-string">&quot;f23&quot;</span>);<br>        treeSet.add(<span class="hljs-string">&quot;12t&quot;</span>);<br><br>        System.out.println(treeSet);<br><br>        <span class="hljs-comment">//TreeSet最大的特点就是，排序</span><br>        <span class="hljs-comment">//在初始化时，使用TreeSet提供的一个构造器，可以传入一个比较器（匿名内部类）</span><br><br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> ((String) o1).compareTo((String) o2);<span class="hljs-comment">//字典序</span><br>            &#125;<br>        &#125;);<br><br>        treeSet1.add(<span class="hljs-string">&quot;bhy&quot;</span>);<br>        treeSet1.add(<span class="hljs-string">&quot;7hy&quot;</span>);<br>        treeSet1.add(<span class="hljs-string">&quot;why&quot;</span>);<br>        treeSet1.add(<span class="hljs-string">&quot;ahy&quot;</span>);<br><br>        System.out.println(treeSet1);<br><br><br>        <span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> ((String)o1).length() - ((String)o2).length();<span class="hljs-comment">//字符串长度进行比较</span><br>            &#125;<br>        &#125;);<br><br>        treeSet2.add(<span class="hljs-string">&quot;bhy&quot;</span>);<br>        treeSet2.add(<span class="hljs-string">&quot;7hy&quot;</span>);<br>        treeSet2.add(<span class="hljs-string">&quot;why&quot;</span>);<br>        treeSet2.add(<span class="hljs-string">&quot;ahy&quot;</span>);<br>        <span class="hljs-comment">//由于长度都为3，因此根据比较规则，后面三个元素判断为与第一个元素重复，添加失败</span><br><br>        System.out.println(treeSet2);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map（双列集合）"><a href="#Map（双列集合）" class="headerlink" title="Map（双列集合）"></a>Map（双列集合）</h2><h3 id="Map接口实现类的特点"><a href="#Map接口实现类的特点" class="headerlink" title="Map接口实现类的特点"></a>Map接口实现类的特点</h3><ul><li>1.用于保存具有映射关系的数据：key-value（即双列元素）;</li><li>2.Map中的key和value可以是<strong>任意引用类型（Object类型）</strong>，会封装到HashMap$Node对象中；</li><li>3.Map中的key不允许重复，原因和HashSet（本质是HashMap）一致：<ul><li>key相同时，后面加入的元素的value值会进行覆盖原value值；</li><li>key不同时，value允许相同；</li><li>key和value可以为null，主要注意的是，Map中只能有一个元素的key为null，但可以有多个value为null；</li></ul></li><li>4.常用String来作为key值；</li><li>5.key和value之间是一对一关系，即通过特定的key可以找到对应的value；</li><li>6.六种遍历方式，Map的遍历主要通过获取keySet，entrySet，values并分别使用<strong>迭代器或者增强for（原理也是迭代器）</strong>来实现；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>map.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>));<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2</span>));<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">3</span>));<br>map.put(<span class="hljs-number">4</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">4</span>));<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5</span>));<br>map.put(<span class="hljs-number">6</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-number">6000</span>, <span class="hljs-number">6</span>));<br><br><span class="hljs-comment">//1.获取keySet</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> map.keySet();<br><br><span class="hljs-comment">//增强for遍历</span><br><span class="hljs-keyword">for</span> (Object key : set) &#123;<br>    System.out.println(key + <span class="hljs-string">&quot;-&quot;</span> + map.get(key));<br>&#125;<br><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> set.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>    System.out.println(next + <span class="hljs-string">&quot;-&quot;</span> + map.get(next));<br>&#125;<br><br><span class="hljs-comment">//2.获取values</span><br><span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();<br><br><span class="hljs-comment">//增强for</span><br><span class="hljs-keyword">for</span> (Object o : values) &#123;<br>    System.out.println(o);<br>&#125;<br><br><span class="hljs-comment">//迭代器</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator1</span> <span class="hljs-operator">=</span> values.iterator();<br><span class="hljs-keyword">while</span> (iterator1.hasNext()) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator1.next();<br>    System.out.println(next);<br>&#125;<br><br><span class="hljs-comment">//3.获取entrySet</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">set1</span> <span class="hljs-operator">=</span> map.entrySet();<br><br><span class="hljs-comment">//增强for</span><br><span class="hljs-keyword">for</span> (Object o : set1) &#123;<br>    Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) o;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;-&quot;</span> + entry.getValue());<br>&#125;<br><br><span class="hljs-comment">//迭代器</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator2</span> <span class="hljs-operator">=</span> set1.iterator();<br><span class="hljs-keyword">while</span> (iterator2.hasNext()) &#123;<br>    Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> (Map.Entry)iterator2.next();<br>    System.out.println(next.getKey() + <span class="hljs-string">&quot;-&quot;</span> + next.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap *"></a>HashMap *</h4><ul><li><p>1.Map接口的实现类，使用频率最高；</p></li><li><p>2.数据以键值对（key-value）的形式存储，key和value是Object类型；</p></li><li><p>3.HashMap没有实现同步，因此是线程不安全的，没有synchronized关键字；</p></li><li><p>4.底层机制：</p><ul><li>1）键值对（key-value）是一个Node类，Node类实现了Map.Entry&lt;K, V&gt;接口；</li><li>2）JDK7.0中，HashMap底层实现是数组+链表；JDK8.0中，HashMap底层实现是数组+链表+红黑树；</li></ul></li><li><p>5.扩容机制</p><ul><li><strong>HashSet与HashMap的扩容机制不一样的地方：</strong><ul><li>1）HashSet在add元素时，传入的key是待添加元素，而<strong>value是一个常量值</strong>；</li><li>2）HashMap在add元素时，传入的是一个程序员<strong>自定义的Object类型的键值对（key-value）</strong>，若add操作时，key发生冲突，则用<strong>待添加元素的value</strong>替换<strong>HashMap中相应位置元素的value</strong>；</li></ul></li></ul></li></ul><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul><li><p>1.Map接口的实现类；</p></li><li><p>2.存放的元素是键值对（key-value）；</p></li><li><p><strong>3.Hashtable的键和值都不能为null；</strong></p></li><li><p>4.使用方法和HashMap基本一样；</p></li><li><p>5.<strong>Hashtable是线程安全的</strong>，而HashMap是线程不安全的，因此，<strong>Hashtable效率低于HashMap</strong>;</p></li><li><p>6.扩容机制：<strong>原容量的2倍+1</strong></p><ul><li>1）通过hashCode()得到hash值，再通过某种算法得到索引值；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得hash值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br><span class="hljs-comment">//获得索引值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br></code></pre></td></tr></table></figure><ul><li><p>2）在存储数据的表table中，检查该索引位置是否已经存放有元素：</p><ul><li>若没有元素，直接调用addEntry()添加元素；</li><li>若有元素，即发生冲突，调用equals()方法进行对key进行比较，如果相同则将原value替换为当前value；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码分析</span><br><span class="hljs-comment">//put()方法中，若冲突，则替换value；</span><br><span class="hljs-keyword">for</span>(; entry != <span class="hljs-literal">null</span> ; entry = entry.next) &#123;<br>    <span class="hljs-keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;<br>        <span class="hljs-type">V</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> entry.value;<br>        entry.value = value;<br>        <span class="hljs-keyword">return</span> old;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3）若Hashtable中的节点（Hashtable中的节点是Entry类型）数量 &gt;&#x3D; table表的阈值(threshold)则进行扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码分析</span><br><span class="hljs-comment">//addEntry()方法中的部分代码</span><br><span class="hljs-keyword">if</span> (count &gt;= threshold) &#123;<br>    <span class="hljs-comment">// Rehash the table if the threshold is exceeded</span><br>    rehash();<span class="hljs-comment">//这里实现扩容</span><br><br>    tab = table;<br>    hash = key.hashCode();<br>    index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br>&#125;<br><br><span class="hljs-comment">//rehash()方法中的部分代码：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> table.length;<br>Entry&lt;?,?&gt;[] oldMap = table;<br><br><span class="hljs-comment">// overflow-conscious code</span><br><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> (oldCapacity &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//原容量2倍+1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>4）Hashtable不会树化；</strong></p></li></ul></li></ul><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul><li>1.底层是HashMap实现；</li></ul><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul><li>1.TreeMap，HashMap都继承自AbstractMap，因此两者很多具体方法实现都大同小异；</li><li>2.TreeSet的底层是TreeMap，<strong>两者的区别</strong>是：<ul><li>TreeSet在add元素时，key是待添加的元素的值，value是常量；</li><li>TreeMap在add元素时，key是待添加元素的键，value是待添加元素的值;</li></ul></li><li>3.HashMap底层通过调用equals()方法判断key是否冲突，而TreeMap则通过调用比较器中定义的比较规则进行判断key是否冲突。<ul><li>TreeMap与HashMap在发生key冲突时，均会将待添加元素的value替换冲突位置元素的value；</li><li>若给TreeMap添加一个自定义类时，如map.put(new Person(), “asasa”)，由于自定义类没有实现Comparable接口的comparaTo方法，因此会报错；</li></ul></li><li>4.源码分析与TreeSet处一致；</li></ul><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul><li>1.Properties继承自Hashtable类，并且实现了Map接口，也是使用一种键值对的形式来保存数据；</li><li>2.Properties还可以用于从  <strong>外部xx.properties文件</strong> 中加载数据到 <strong>Properties类对象</strong> ，并且进行读取和修改；</li><li>3.使用特点与Hashtable类似；</li></ul><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><ul><li>1.Collections是一个操作Set、List和Map等集合的工具类；</li><li>2.Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作；</li><li>3.常用的方法介绍：<ul><li>排序操作<ul><li>reverse(List)：反转List中元素的顺序；</li><li>shuffle(List)：对List集合中的元素进行随机排序；</li><li>sort(List)：根据元素的自然顺序对指定的List集合元素按升序排序；</li><li>sort(List, Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序；</li><li>swap(List, int, int)：将指定List集合中的 i 处元素和 j 元素进行交换；</li></ul></li><li>查找、替换操作<ul><li>Object max(Collecton)：根据元素自然顺序，返回给定集合中的最大元素；</li><li>Object max(Collection, Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素；</li><li>Object min(Collection)：同理，max;</li><li>Object min(Collection, Comparator)：同理，max;</li><li>int frequency(Collection, Object)：返回指定集合中指定元素的出现次数；</li><li>void copy(List dest, List src)：将集合src中的内容复制到集合dest中；</li><li>boolean replaceAll(List list, Object oldValue, Object newVal)：使用新值替换List集合中的所有旧值；</li></ul></li></ul></li></ul><h2 id="集合选型规则"><a href="#集合选型规则" class="headerlink" title="集合选型规则"></a>集合选型规则</h2><ul><li>选择什么集合实现类，主要取决于业务操作特点，根据集合实现类的特性选择。</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>1）先判断数据存储类型：</p><ul><li>一组对象 &#x3D;&gt; 单列集合Collection</li><li>一组键值对 &#x3D;&gt; 双列集合Map</li></ul></li><li><p>2）若是一组对象，即单列集合Collection，判断是否允许重复：</p><ul><li>允许重复 &#x3D;&gt; List<ul><li>增删多：LinkedList，底层维护了双向链表；</li><li>改查多：ArrayList， 底层维护了Object类型的可变数组；</li></ul></li><li>不允许重复 &#x3D;&gt; Set<ul><li>无序：HashSet，底层是HashMap实现，即数组+链表+红黑树；</li><li>排序：TreeSet，</li><li>插入顺序和取出顺序一致：LinkedHashSet，数组+双向链表，底层使用LinkedHashMap实现，而LinkedHashMap的底层是HashMap实现的；</li></ul></li></ul></li><li><p>3）若是一组键值对，即双列集合Map：</p><ul><li>键(value)无序：HashMap；</li><li>键(value)排序：TreeMap</li><li>键(value)插入顺序和取出顺序一致：LinkedHashMap，底层使用HashMap实现；</li><li>读取文件：Properties</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-运算符总结</title>
    <link href="/2023/02/14/Java-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/14/Java-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-运算符总结"><a href="#Java-运算符总结" class="headerlink" title="Java-运算符总结"></a>Java-运算符总结</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>&#x2F;</td><td>除法</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>++</td><td>自增</td></tr><tr><td>–</td><td>自减</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与，（5&amp;6） &#x3D;&#x3D;&gt; (0101 &amp; 0110) &#x3D;&#x3D;&gt; 4</td></tr><tr><td>|</td><td>按位或，（5|6） &#x3D;&#x3D;&gt; (0101 | 0110) &#x3D;&#x3D;&gt; 0111 &#x3D;&#x3D;&#x3D;&gt; 7</td></tr><tr><td>^</td><td>按位异或，（5^6） &#x3D;&#x3D;&gt; (0101 ^ 0110) &#x3D;&#x3D;&gt; 0011 &#x3D;&#x3D;&gt; 3</td></tr><tr><td>~</td><td>按位取反，（~5） &#x3D;&#x3D;&gt; 0101 &#x3D;&#x3D;&gt; 1010(负数的补码转换成原码，按位取反加一) &#x3D;&#x3D;&gt; -6</td></tr><tr><td>&lt;&lt;</td><td>按位左移，5&lt;&lt;2  &#x3D;&#x3D;&gt; 0101 &gt;&gt; 2 &#x3D;&#x3D;&gt;010100 &#x3D;&#x3D;&gt; 20</td></tr><tr><td>&gt;&gt;</td><td>按位右移，5&gt;&gt;2  &#x3D;&#x3D;&gt; 0101 &gt;&gt; 2 &#x3D;&#x3D;&gt; 1</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零，5&gt;&gt;&gt;2  &#x3D;&#x3D;&gt; 0101 &gt;&gt;&gt; 2 &#x3D;&#x3D;&gt;0001 &#x3D;&#x3D;&gt; 1</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>||</td><td>逻辑或</td></tr><tr><td>!</td><td>逻辑非</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值</td></tr><tr><td>+&#x3D;</td><td>加和赋值，A +&#x3D; B &#x3D;&#x3D;&#x3D;&gt; A &#x3D; A + B</td></tr><tr><td>-&#x3D;</td><td>减和赋值</td></tr><tr><td>*&#x3D;</td><td>乘和赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>除和赋值</td></tr><tr><td>%&#x3D;</td><td>取模和赋值，A%B &#x3D;&#x3D;&#x3D;&gt; A &#x3D; A % B</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移位赋值，A&lt;&lt;&#x3D;2 &#x3D;&#x3D;&#x3D;&gt; A &#x3D; A&lt;&lt;2</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移位赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或赋值</td></tr><tr><td>|</td><td>按位或赋值</td></tr></tbody></table><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>?  :</td><td>三元运算符</td></tr><tr><td>instanceof</td><td>用于操作对象实例，检查该对象是否是一个特定的类型（类类型或累接口）</td></tr></tbody></table><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>表中，自上而下优先级依次降低。</p><table><thead><tr><th>类别</th><th>操作符</th><th>运算顺序</th></tr></thead><tbody><tr><td>后缀</td><td>()、 []、 .(点操作符)</td><td>自左向右</td></tr><tr><td>一元</td><td>a++、a–</td><td>自左向右</td></tr><tr><td>一元</td><td>++a、–a、+、-、~、!</td><td>自右向左</td></tr><tr><td>乘 除 取模</td><td>*、&#x2F;、%</td><td>自左向右</td></tr><tr><td>加 减</td><td>+、-</td><td>自左向右</td></tr><tr><td>移位</td><td>&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;</td><td>自左向右</td></tr><tr><td>关系</td><td>&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;</td><td>自左向右</td></tr><tr><td>相等</td><td>&#x3D;&#x3D;、!&#x3D;</td><td>自左向右</td></tr><tr><td>按位与</td><td>&amp;</td><td>自左向右</td></tr><tr><td>按位异或</td><td>^</td><td>自左向右</td></tr><tr><td>按位或</td><td>|</td><td>自左向右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>自左向右</td></tr><tr><td>逻辑或</td><td>||</td><td>自左向右</td></tr><tr><td>条件</td><td>? :</td><td>自右向左</td></tr><tr><td>赋值</td><td>&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&gt;&gt;&#x3D;、&lt;&lt;&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;、、</td><td>自右向左</td></tr><tr><td>逗号</td><td>,</td><td>自左向右</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-经典同层去重（剪枝）</title>
    <link href="/2023/02/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89/"/>
    <url>/2023/02/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-经典同层去重（剪枝）"><a href="#回溯算法-经典同层去重（剪枝）" class="headerlink" title="回溯算法-经典同层去重（剪枝）"></a>回溯算法-经典同层去重（剪枝）</h3><h4 id="LeetCode参考题目："><a href="#LeetCode参考题目：" class="headerlink" title="LeetCode参考题目："></a>LeetCode参考题目：</h4><ul><li>LeetCode_40</li></ul><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/subsets">https://leetcode.cn/problems/subsets</a></p><ul><li>LeetCode_90</li></ul><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/subsets-ii">https://leetcode.cn/problems/subsets-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>LeetCode_40之前发过一篇文章，没怎么懂，但是回溯过程如果不去重（剪枝），会超出时间限制！！</strong></p><p><strong>下面是去重的写法</strong></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ansList;<br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; cur_list;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index == nums.length)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//关键地方：同层去重，剪枝操作！</span><br>            <span class="hljs-keyword">if</span>(i &gt; index &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            cur_list.add(nums[i]);<br><br>            List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur_list);<span class="hljs-comment">//重新保存，防止覆盖</span><br>            ansList.add(list1);<br><br>            backTrack(nums, i+<span class="hljs-number">1</span>);<br><br>            cur_list.remove(cur_list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur_list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<span class="hljs-comment">//先把空集加入</span><br><br>        backTrack(nums, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ansList;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法一般解题步骤</title>
    <link href="/2023/02/10/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/"/>
    <url>/2023/02/10/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法一般解题步骤"><a href="#回溯算法一般解题步骤" class="headerlink" title="回溯算法一般解题步骤"></a>回溯算法一般解题步骤</h3><ul><li><p><strong>确定回溯函数模板返回值以及参数</strong></p><ul><li>返回值：一般是void；</li><li>参数：先写回溯逻辑，需要什么参数再填进去；</li></ul></li><li><p><strong>回溯函数终止条件</strong></p><ul><li>遍历到叶子结点时终止：即将回溯遍历整个过程遍历成二叉树；</li></ul></li><li><p><strong>回溯搜索过程的遍历过程</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回溯算法解决的问题"><a href="#回溯算法解决的问题" class="headerlink" title="回溯算法解决的问题"></a>回溯算法解决的问题</h3><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合；</li><li>切割问题：一个字符串按一定规则有几种切割方式；</li><li>子集问题：一个N个数的集合里有多少符合条件的子集；</li><li>排列问题：N个数按一定规则全排列，有几种排列方式；</li><li>棋盘问题：N皇后，解数独等等；</li></ul>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令整理</title>
    <link href="/2023/02/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2023/02/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Git常用命令整理"><a href="#Git常用命令整理" class="headerlink" title="Git常用命令整理"></a>Git常用命令整理</h2><h3 id="Git-全局设置"><a href="#Git-全局设置" class="headerlink" title="Git 全局设置"></a>Git 全局设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;用户名&quot;<br>git config --global user.email &quot;用户邮箱&quot;<br></code></pre></td></tr></table></figure><h3 id="创建新的仓库并提交代码"><a href="#创建新的仓库并提交代码" class="headerlink" title="创建新的仓库并提交代码"></a>创建新的仓库并提交代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone 仓库地址<br>cd 仓库目录<br>git switch -c 新的分支名<br>touch README.md <br>git add README.md<br>git commit -m &quot;本次提交的描述信息&quot;<br>git push -u origin 新的分支名<br></code></pre></td></tr></table></figure><h3 id="推送本地现有文件夹"><a href="#推送本地现有文件夹" class="headerlink" title="推送本地现有文件夹"></a>推送本地现有文件夹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">cd 文件夹目录<br>git init <br>git remote add origin 远程仓库地址<br>git add .<br>git commit -m &quot;描述信息&quot;<br>git push -u origin 分支名<br></code></pre></td></tr></table></figure><h3 id="origin-的含义"><a href="#origin-的含义" class="headerlink" title="origin 的含义"></a>origin 的含义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">“git remote add origin 远程仓库地址”<br><br>origin 是 该远程仓库的别名<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">#克隆远程仓库的指定分支到本地<br>git clone -b 远程分支名 远程分支地址<br><br>#pull远程仓库的指定分支<br>git pull origin 远程指定分支<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-LeetCode_T40</title>
    <link href="/2023/02/08/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95_LeetCode_T40/"/>
    <url>/2023/02/08/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95_LeetCode_T40/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-LeetCode-T40"><a href="#回溯算法-LeetCode-T40" class="headerlink" title="回溯算法_LeetCode_T40"></a>回溯算法_LeetCode_T40</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/combination-sum-ii">https://leetcode.cn/problems/combination-sum-ii</a></p></li></ul><h3 id="超时写法"><a href="#超时写法" class="headerlink" title="超时写法"></a>超时写法</h3><ul><li>回溯遍历所有组合；</li><li>最后对所有满足条件的组合进行去重；</li><li>ps：我一开始就是这么写的，然后直接提交，“超出时间限制”。</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>代码随想录给出的题解；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">( <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target )</span> &#123;<br>    <span class="hljs-comment">//为了将重复的数字都放到一起，所以先进行排序</span><br>    Arrays.sort( candidates );<br>    backTracking( candidates, target, <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">( <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start )</span> &#123;<br>    <span class="hljs-keyword">if</span> ( sum == target ) &#123;<br>      res.add( <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;( path ) );<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++ ) &#123;<br>      <span class="hljs-comment">//正确剔除重复解的办法</span><br>      <span class="hljs-comment">//跳过同一树层使用过的元素</span><br>      <span class="hljs-keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] ) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      sum += candidates[i];<br>      path.add( candidates[i] );<br>      <span class="hljs-comment">// i+1 代表当前组内元素只选取一次</span><br>      backTracking( candidates, target, i + <span class="hljs-number">1</span> );<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> path.getLast();<br>      sum -= temp;<br>      path.removeLast();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划一般解题步骤</title>
    <link href="/2023/02/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/"/>
    <url>/2023/02/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="动态规划一般解题步骤"><a href="#动态规划一般解题步骤" class="headerlink" title="动态规划一般解题步骤"></a>动态规划一般解题步骤</h3><ul><li><p><strong>确定dp数组以及下标含义</strong></p></li><li><p><strong>确定递推公式</strong></p></li><li><p><strong>dp数组如何初始化</strong></p></li><li><p><strong>确定遍历顺序</strong></p></li><li><p><strong>举例推导dp数组</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo上传文章、分类及标签等操作</title>
    <link href="/2023/02/07/Hexo%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%E3%80%81%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/02/07/Hexo%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%E3%80%81%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo上传文章、分类及标签等操作"><a href="#Hexo上传文章、分类及标签等操作" class="headerlink" title="Hexo上传文章、分类及标签等操作"></a>Hexo上传文章、分类及标签等操作</h2><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li>本地写好.md文档，复制到\source\_posts文件夹下；</li><li>在.md文档开头加上一下信息：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">title: 文章标题<br>date: 文章建立日期<br>categories：文章分类（可以有多级分类）<br>tags: 文章标签（可以有多个）<br></code></pre></td></tr></table></figure><p>参数列表及描述</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td></td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td><td></td></tr><tr><td>keywords</td><td>仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td><td></td></tr></tbody></table><ul><li>在git bash中输入 <strong>hexo g</strong> (完整命令为hexo generate)，用于生成静态文件；</li><li>输入<strong>hexo d</strong>(hexo deploy)发布到git仓库上；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建站纪念！</title>
    <link href="/2022/11/24/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5%EF%BC%81/"/>
    <url>/2022/11/24/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h2 id="建站纪念！"><a href="#建站纪念！" class="headerlink" title="建站纪念！"></a>建站纪念！</h2><h3 id="纪念日"><a href="#纪念日" class="headerlink" title="纪念日"></a>纪念日</h3><p><strong>本站出生于公元2022年11月24日，坐标北京市海淀区</strong></p><h3 id="为什么创建这个网站？"><a href="#为什么创建这个网站？" class="headerlink" title="为什么创建这个网站？"></a>为什么创建这个网站？</h3><p>本人是一名计算机专业在读硕士研究生，如本站大标题，趁年轻，多折腾。</p><p>如需进一步交流学习，可通过”关于”页面中的联系方式找到我。</p><p>欢迎大家来玩。</p><h3 id="本站内容的大致方向"><a href="#本站内容的大致方向" class="headerlink" title="本站内容的大致方向"></a>本站内容的大致方向</h3><ul><li>硕士期间，就目前来说，主要是做OpenHarmony相关的探索，因此，本站会发一些有关学习OpenHarmony的笔记。</li><li>LeetCode刷题记录。</li><li>Java学习笔记。</li><li>关于记录生活相关，南方人第一次去国际大都市读书，目前入学俩月多一点，还挺多感慨。（当然，后期应该会分享吐槽导师，读研生活以及读研经验等等）</li><li>后面再想想其他话题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
