<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java学习-将基本数据类型封装成包装类的好处</title>
    <link href="/2023/02/16/Java%E5%AD%A6%E4%B9%A0-%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E6%88%90%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <url>/2023/02/16/Java%E5%AD%A6%E4%B9%A0-%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E6%88%90%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Java学习-将基本数据类型封装成包装类的好处"><a href="#Java学习-将基本数据类型封装成包装类的好处" class="headerlink" title="Java学习-将基本数据类型封装成包装类的好处"></a>Java学习-将基本数据类型封装成包装类的好处</h2><ul><li>1.可以赋null值，有些地方需要赋null，但是基本数据类型不能赋null；</li></ul><ul><li><pre><code class="hljs"> 2.有缓存机制。例如Integer缓存了-128~127区间的数值；</code></pre></li><li><pre><code class="hljs"> 3.集合中只能存放Object及其子类 类型的数据，不能存放基本数据类型；</code></pre></li><li><pre><code class="hljs"> 可能还有其它的；</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
      <category>Wrapper类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Wrapper类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-transient关键字</title>
    <link href="/2023/02/16/Java-transient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/02/16/Java-transient%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-transient关键字"><a href="#Java-transient关键字" class="headerlink" title="Java-transient关键字"></a>Java-transient关键字</h1><ul><li><p>1.在 Java 中，<code>transient</code> 是一个关键字，用于修饰类的成员变量，表示该变量不参与序列化过程。</p></li><li><p>2.在 Java 中，当需要将一个对象序列化为字节流并在网络或者文件中传输时，会使用 <code>ObjectOutputStream</code> 进行序列化操作。而 <code>transient</code> 关键字可以用来控制序列化过程中哪些成员变量需要被序列化，哪些成员变量不需要被序列化。</p></li><li><p>3.具体来说，被 <code>transient</code> 修饰的变量，当对象被序列化时，这个变量的值不会被写入到序列化输出流中；而当对象被反序列化时，这个变量的值会被默认初始化，也就是赋予该变量类型的默认值。</p></li><li><p>4.使用 <code>transient</code> 的场景通常是当某个成员变量不应该被序列化时，例如一些敏感信息、临时计算结果等，这些信息不需要被存储在序列化的字节流中。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习-ChatGPT给出的学习计划</title>
    <link href="/2023/02/15/MySQL-ChatGPT%E7%BB%99%E5%87%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2023/02/15/MySQL-ChatGPT%E7%BB%99%E5%87%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习-ChatGPT给出的学习计划"><a href="#MySQL学习-ChatGPT给出的学习计划" class="headerlink" title="MySQL学习-ChatGPT给出的学习计划"></a>MySQL学习-ChatGPT给出的学习计划</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>掌握 SQL 基本语法和常用函数</li><li>学会使用 SQL 进行数据查询和数据分析</li><li>能够使用 SQL 对数据进行增、删、改操作</li><li>了解 MySQL 数据库的设计和优化原则</li></ul><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li>B 站黑马程序员 SQL 视频课程：<a href="https://www.bilibili.com/video/BV1YJ411P7dU">https://www.bilibili.com/video/BV1YJ411P7dU</a></li><li>MySQL 官方文档：<a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></li></ul><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><h3 id="第-1-2-周：SQL-基础知识"><a href="#第-1-2-周：SQL-基础知识" class="headerlink" title="第 1-2 周：SQL 基础知识"></a>第 1-2 周：SQL 基础知识</h3><ul><li>观看黑马程序员 SQL 视频课程第 1-11 讲</li><li>学习 SQL 基本语法、查询语句、条件查询、排序查询、分组查询等基础知识</li></ul><h3 id="第-3-4-周：SQL-函数和操作"><a href="#第-3-4-周：SQL-函数和操作" class="headerlink" title="第 3-4 周：SQL 函数和操作"></a>第 3-4 周：SQL 函数和操作</h3><ul><li>观看黑马程序员 SQL 视频课程第 12-20 讲</li><li>学习 SQL 中常用的函数，如字符串函数、数学函数、日期函数等</li><li>学习 SQL 中的增、删、改操作</li></ul><h3 id="第-5-6-周：高级-SQL-操作和数据分析"><a href="#第-5-6-周：高级-SQL-操作和数据分析" class="headerlink" title="第 5-6 周：高级 SQL 操作和数据分析"></a>第 5-6 周：高级 SQL 操作和数据分析</h3><ul><li>观看黑马程序员 SQL 视频课程第 21-31 讲</li><li>学习 SQL 中的高级操作，如子查询、联合查询、事务、视图等</li><li>学习如何使用 SQL 进行数据分析，如聚合统计、数据透视等</li></ul><h3 id="第-7-8-周：MySQL-数据库设计和优化"><a href="#第-7-8-周：MySQL-数据库设计和优化" class="headerlink" title="第 7-8 周：MySQL 数据库设计和优化"></a>第 7-8 周：MySQL 数据库设计和优化</h3><ul><li>观看黑马程序员 SQL 视频课程第 32-38 讲</li><li>学习 MySQL 数据库的设计原则和优化方法</li><li>了解 MySQL 数据库的常用工具和技巧，如索引优化、存储过程、触发器等</li></ul><h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ul><li>每天至少花 2 小时学习 SQL，建议在学习期间尽量集中注意力，减少干扰和分心。</li><li>在学习过程中，尝试使用 SQL 对实际数据进行操作和查询，以加深印象和提高实战能力。</li><li>学习过程中，可以结合官方文档和其他 SQL 学习资源，以更好地理解和掌握 SQL 知识。</li><li>如果时间允许，建议参加在线课程或者线下培训，与老师和同学交流，提高学习效果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习-MySQL介绍</title>
    <link href="/2023/02/14/MySQL-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/02/14/MySQL-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习-MySQL介绍"><a href="#MySQL学习-MySQL介绍" class="headerlink" title="MySQL学习-MySQL介绍"></a>MySQL学习-MySQL介绍</h1><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><p>Database，简称DB；</p></li><li><p>存储数据的仓库，数据是有组织的进行存储；</p></li></ul><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><ul><li><p>Database Management System，简称DBMS；</p></li><li><p>操纵和管理数据库的大型软件；</p></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>Structured Query Language，简称SQL；</li><li>操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准；</li></ul><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul><li><p><strong>程序员</strong> 通过 <strong>SQL</strong> 操作 <strong>数据库管理系统</strong>；</p></li><li><p>通过 <strong>数据库管理系统</strong> 来操作 <strong>数据库以及数据库中的数据</strong>；</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-经典同层去重（flag标记数组）</title>
    <link href="/2023/02/14/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88flag%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <url>/2023/02/14/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88flag%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-经典同层去重（flag标记数组）"><a href="#回溯算法-经典同层去重（flag标记数组）" class="headerlink" title="回溯算法-经典同层去重（flag标记数组）"></a>回溯算法-经典同层去重（flag标记数组）</h3><h4 id="LeetCode参考题目："><a href="#LeetCode参考题目：" class="headerlink" title="LeetCode参考题目："></a>LeetCode参考题目：</h4><ul><li>LeetCode_491</li></ul><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/non-decreasing-subsequences">https://leetcode.cn/problems/non-decreasing-subsequences</a></p><p><strong>flag标记数组去重也可以解决LeetCode_40和LeetCode_90中同层去重问题！！所以，尽量使用这个进行同层去重！！！</strong></p><p><strong>下面是去重的写法</strong></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ansList;<br>    List&lt;Integer&gt; cur_s;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index == nums.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">205</span>];<span class="hljs-comment">//标记数组，同层遍历时，前面已经使用过的数字，不能在使用了！</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>((cur_s.size()&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; cur_s.get(cur_s.size()-<span class="hljs-number">1</span>)) || flag[nums[i] +<span class="hljs-number">100</span>] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            cur_s.add(nums[i]);<br>            <span class="hljs-comment">//使用过的数字就标记为1，由于nums[i]的范围在【-100，100】之间，因此需要加上100，避免下标为负数</span><br>            flag[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">if</span>(cur_s.size() &gt;= <span class="hljs-number">2</span>)<br>                ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur_s));<br><br>            backTrack(nums, i+<span class="hljs-number">1</span>);<br><br>            cur_s.remove(cur_s.size()-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur_s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        backTrack(nums, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ansList;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合框架体系整理（持续更新！）</title>
    <link href="/2023/02/14/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB/"/>
    <url>/2023/02/14/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h1><h2 id="Collection-单列集合"><a href="#Collection-单列集合" class="headerlink" title="Collection  (单列集合)"></a>Collection  (单列集合)</h2><h3 id="Collection接口实现类的特点"><a href="#Collection接口实现类的特点" class="headerlink" title="Collection接口实现类的特点"></a>Collection接口实现类的特点</h3><ul><li>1.可以存放多个Object类型的元素；</li><li>2.有些可以存放重复元素，有些不行；</li><li>3.有些是有序的（List），有些不是有序的（Set）；</li><li>4.没有直接的实现子类，是通过实现它的子接口Set和List实现的；</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li>List接口是Collection接口的子接口，特点：<ul><li>1.List集合类中的元素有序，即添加顺序和取出顺序一直，且元素可以重复；</li><li>2.List集合类中的元素支持索引，例如list.get(index)，返回的是集合中的第index+1个元素;</li></ul></li><li>遍历方式<ul><li>1.Iterator</li><li>2.增强for</li><li>3.普通for（即支持索引）</li></ul></li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList *"></a>ArrayList *</h4><ul><li>1.List接口的实现类；</li><li>2.可以存放任意类型的数据，包括null；</li><li>3.底层数据存储是由数组实现的；</li><li>4.基本等同于Vector，但是它线程不安全 &#x3D;&gt; 执行效率（源码中没有使用synchronized关键字修饰）；</li><li>5.在多线程情况下，不建议使用ArrayList；</li><li>6.扩容机制<ul><li>1）ArrayList维护了一个Object类型的数组elementData;</li><li>2）创建ArrayList对象时：<ul><li>如果使用的是无参构造器，则初始elementData数组容量为0，第一次添加元素，则扩容elementData数组容量为<strong>10</strong>，如需再次扩容，则扩容原elementData数组容量的<strong>1.5倍</strong>；</li><li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如需再次扩容，则扩容原elementData数组容量的<strong>1.5倍</strong>；</li></ul></li></ul></li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li><p>1.List接口的实现类</p></li><li><p>2.LinkedList底层实现了双向链表和双端队列的特点：</p><ul><li>每个节点都是Node对象；</li><li>底层维护了first，last，分别指向链表的首、尾节点；</li><li>节点内部维护了prev，next，item三个属性，prev指向前一个节点，next指向后一个节点，实现双向链表；</li></ul></li><li><p>3.可以添加任意类型的元素，包括null，且可以重复；</p></li><li><p>线程不安全，没有同步；</p></li><li><p>4.添加和删除操作效率较高（链表的优势）,不涉及到扩容问题；</p></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li><p>1.实现了List接口，并且继承了ArrayList类；</p></li><li><p>2.底层和ArrayList一样维护了一个Object类型的数组，elementData；</p></li><li><p>3.Vector支持线程同步，即线程安全，Vector类的操作方法（如setXXX()，getXXX()方法）带有synchronized关键字修饰；</p></li><li><p>4.扩容机制</p><ul><li><p>创建ArrayList对象时：</p><ul><li>如果使用的是无参构造器，则初始elementData数组容量为0，第一次添加元素，则扩容elementData数组容量为<strong>10</strong>，如需再次扩容，则扩容原elementData数组容量的<strong>2倍</strong>；</li><li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如需再次扩容，则扩容原elementData数组容量的<strong>2倍</strong>；</li></ul></li></ul></li></ul><h4 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h4><table><thead><tr><th></th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，链表直接追加</td><td>较低</td></tr></tbody></table><p><strong>上述是比较常用的实现子类，还有很多其他的实现子类；</strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>无序（添加和取出顺序不一致），且没有索引（例如：不能使用普通for进行遍历）；<ul><li>添加的顺序与取出顺序不一致，<strong>但是取出的顺序是固定的；</strong></li></ul></li><li>不允许有重复元素，因此Set中最多包含一个null值；</li><li>JDK API中Set接口的实现类有：<ul><li>HashSet</li><li>TreeSet</li><li>还有很多其他实现类和子接口；</li></ul></li><li>遍历方式<ul><li>1.Iterator</li><li>2.增强for</li><li><strong>3.不能使用普通for遍历（即不支持索引）</strong></li></ul></li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet *"></a>HashSet *</h4><ul><li><p>1.Set接口的实现类；</p></li><li><p>2.HashSet底层实现实际上是一个HashMap；</p></li><li><p>3.不能有重复元素（Set接口的实现类），可以存放null值，但是只能存放一个；</p></li><li><p>4.HashSet不保证元素有序，取决于hash后的索引结果；</p></li><li><p>5.<strong>低层扩容机制</strong>，HashMap &#x3D;&gt; <strong>数组+链表+红黑树</strong></p><ul><li><p>1）添加一个元素时，先通过hash算法得到hash值，通过<strong>某个</strong>算法转成索引值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//hash()方法，获得hash值</span><br><span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//“某个算法”即i = (n - 1) &amp; hash  实现：hash值 ==&gt; table的索引值</span><br>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]<br></code></pre></td></tr></table></figure></li><li><p>2）找到存储数据表table，检查该索引位置是否已经存放有元素：</p><ul><li>若没有元素，直接加入；</li><li>若有元素，调用equals()方法进行比较，如果相同则放弃添加，如果不相同则添加到链表最后；</li></ul></li><li><p>3）在Java8中，如果一条链表的元素个数 &gt;&#x3D; TREEIFY_THRESHOLD值（默认值是8），并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY值(默认值是64)时，会将该链表转化为一颗红黑树；</p></li><li><p>4）若仅该链表元素个数 &gt; 8，而table的大小仍 &lt; 64时，先对table数组进行扩容；</p><ul><li><strong>table数组扩容机制</strong>：</li><li>（1）HashMap初始化时设定了一个loadFactor值，默认初始为0.75；</li><li>（2）table的容量默认初始为16；</li><li>（3）当table中的元素个数(包括链表中的节点) &gt; 阈值（即threshold值，此时为16 * 0.75&#x3D;12）时，table容量扩大为原来的2倍，阈值threshold为 loadFactor * table的容量；</li><li>（4）数组扩容后，元素的位置也会进行重新分布(具体见源码中的resize()方法)；</li></ul></li></ul></li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li>1.HashSet的子类；</li><li>2.底层是一个<strong>LinkedHashMap</strong>（HashMap的子类），底层维护了一个<strong>数组+双向链表</strong>；</li><li>3.根据元素的<strong>hashCode值</strong>来决定元素的存储位置，同时使用链表维护元素的次序，即加入顺序和取出顺序一致；</li><li>4.不允许插入重复元素；</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>- </p><h2 id="Map（双列集合）"><a href="#Map（双列集合）" class="headerlink" title="Map（双列集合）"></a>Map（双列集合）</h2><h3 id="Map接口实现类的特点"><a href="#Map接口实现类的特点" class="headerlink" title="Map接口实现类的特点"></a>Map接口实现类的特点</h3><ul><li>1.用于保存具有映射关系的数据：key-value（即双列元素）;</li><li>2.Map中的key和value可以是<strong>任意引用类型（Object类型）</strong>，会封装到HashMap$Node对象中；</li><li>3.Map中的key不允许重复，原因和HashMap一致；<ul><li>key相同时，后面加入的元素的value值会进行覆盖原value值；</li><li>key不同时，value允许相同；</li><li>key和value可以为null，主要注意的是，Map中只能有一个元素的key为null，但可以有多个value为null；</li></ul></li><li>4.常用String来作为key值；</li><li>5.key和value之间是一对一关系，即通过特定的key可以找到对应的value；</li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap *"></a>HashMap *</h4><p>- </p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-运算符总结</title>
    <link href="/2023/02/14/Java-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/14/Java-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-运算符总结"><a href="#Java-运算符总结" class="headerlink" title="Java-运算符总结"></a>Java-运算符总结</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>&#x2F;</td><td>除法</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>++</td><td>自增</td></tr><tr><td>–</td><td>自减</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与，（5&amp;6） &#x3D;&#x3D;&gt; (0101 &amp; 0110) &#x3D;&#x3D;&gt; 4</td></tr><tr><td>|</td><td>按位或，（5|6） &#x3D;&#x3D;&gt; (0101 | 0110) &#x3D;&#x3D;&gt; 0111 &#x3D;&#x3D;&#x3D;&gt; 7</td></tr><tr><td>^</td><td>按位异或，（5^6） &#x3D;&#x3D;&gt; (0101 ^ 0110) &#x3D;&#x3D;&gt; 0011 &#x3D;&#x3D;&gt; 3</td></tr><tr><td>~</td><td>按位取反，（~5） &#x3D;&#x3D;&gt; 0101 &#x3D;&#x3D;&gt; 1010(负数的补码转换成原码，按位取反加一) &#x3D;&#x3D;&gt; -6</td></tr><tr><td>&lt;&lt;</td><td>按位左移，5&lt;&lt;2  &#x3D;&#x3D;&gt; 0101 &gt;&gt; 2 &#x3D;&#x3D;&gt;010100 &#x3D;&#x3D;&gt; 20</td></tr><tr><td>&gt;&gt;</td><td>按位右移，5&gt;&gt;2  &#x3D;&#x3D;&gt; 0101 &gt;&gt; 2 &#x3D;&#x3D;&gt; 1</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零，5&gt;&gt;&gt;2  &#x3D;&#x3D;&gt; 0101 &gt;&gt;&gt; 2 &#x3D;&#x3D;&gt;0001 &#x3D;&#x3D;&gt; 1</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>||</td><td>逻辑或</td></tr><tr><td>!</td><td>逻辑非</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值</td></tr><tr><td>+&#x3D;</td><td>加和赋值，A +&#x3D; B &#x3D;&#x3D;&#x3D;&gt; A &#x3D; A + B</td></tr><tr><td>-&#x3D;</td><td>减和赋值</td></tr><tr><td>*&#x3D;</td><td>乘和赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>除和赋值</td></tr><tr><td>%&#x3D;</td><td>取模和赋值，A%B &#x3D;&#x3D;&#x3D;&gt; A &#x3D; A % B</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移位赋值，A&lt;&lt;&#x3D;2 &#x3D;&#x3D;&#x3D;&gt; A &#x3D; A&lt;&lt;2</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移位赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或赋值</td></tr><tr><td>|</td><td>按位或赋值</td></tr></tbody></table><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>?  :</td><td>三元运算符</td></tr><tr><td>instanceof</td><td>用于操作对象实例，检查该对象是否是一个特定的类型（类类型或累接口）</td></tr></tbody></table><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>表中，自上而下优先级依次降低。</p><table><thead><tr><th>类别</th><th>操作符</th><th>运算顺序</th></tr></thead><tbody><tr><td>后缀</td><td>()、 []、 .(点操作符)</td><td>自左向右</td></tr><tr><td>一元</td><td>a++、a–</td><td>自左向右</td></tr><tr><td>一元</td><td>++a、–a、+、-、~、!</td><td>自右向左</td></tr><tr><td>乘 除 取模</td><td>*、&#x2F;、%</td><td>自左向右</td></tr><tr><td>加 减</td><td>+、-</td><td>自左向右</td></tr><tr><td>移位</td><td>&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;</td><td>自左向右</td></tr><tr><td>关系</td><td>&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;</td><td>自左向右</td></tr><tr><td>相等</td><td>&#x3D;&#x3D;、!&#x3D;</td><td>自左向右</td></tr><tr><td>按位与</td><td>&amp;</td><td>自左向右</td></tr><tr><td>按位异或</td><td>^</td><td>自左向右</td></tr><tr><td>按位或</td><td>|</td><td>自左向右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>自左向右</td></tr><tr><td>逻辑或</td><td>||</td><td>自左向右</td></tr><tr><td>条件</td><td>? :</td><td>自右向左</td></tr><tr><td>赋值</td><td>&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&gt;&gt;&#x3D;、&lt;&lt;&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;、、</td><td>自右向左</td></tr><tr><td>逗号</td><td>,</td><td>自左向右</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-经典同层去重（剪枝）</title>
    <link href="/2023/02/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89/"/>
    <url>/2023/02/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E5%90%8C%E5%B1%82%E5%8E%BB%E9%87%8D%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-经典同层去重（剪枝）"><a href="#回溯算法-经典同层去重（剪枝）" class="headerlink" title="回溯算法-经典同层去重（剪枝）"></a>回溯算法-经典同层去重（剪枝）</h3><h4 id="LeetCode参考题目："><a href="#LeetCode参考题目：" class="headerlink" title="LeetCode参考题目："></a>LeetCode参考题目：</h4><ul><li>LeetCode_40</li></ul><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/subsets">https://leetcode.cn/problems/subsets</a></p><ul><li>LeetCode_90</li></ul><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/subsets-ii">https://leetcode.cn/problems/subsets-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>LeetCode_40之前发过一篇文章，没怎么懂，但是回溯过程如果不去重（剪枝），会超出时间限制！！</strong></p><p><strong>下面是去重的写法</strong></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ansList;<br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; cur_list;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index == nums.length)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//关键地方：同层去重，剪枝操作！</span><br>            <span class="hljs-keyword">if</span>(i &gt; index &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            cur_list.add(nums[i]);<br><br>            List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur_list);<span class="hljs-comment">//重新保存，防止覆盖</span><br>            ansList.add(list1);<br><br>            backTrack(nums, i+<span class="hljs-number">1</span>);<br><br>            cur_list.remove(cur_list.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        cur_list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<span class="hljs-comment">//先把空集加入</span><br><br>        backTrack(nums, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> ansList;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法一般解题步骤</title>
    <link href="/2023/02/10/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/"/>
    <url>/2023/02/10/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法一般解题步骤"><a href="#回溯算法一般解题步骤" class="headerlink" title="回溯算法一般解题步骤"></a>回溯算法一般解题步骤</h3><ul><li><p><strong>确定回溯函数模板返回值以及参数</strong></p><ul><li>返回值：一般是返回void；</li><li>参数：先写回溯逻辑，需要什么参数再填进去；</li></ul></li><li><p><strong>回溯函数终止条件</strong></p><ul><li>遍历到叶子结点时终止回溯过程（即：将回溯遍历整个过程遍历成二叉树）；</li></ul></li><li><p><strong>回溯搜索过程的遍历过程</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        <br>        处理节点;<br>        <br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归回溯</span><br>        <br>        撤销处理结果;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令整理</title>
    <link href="/2023/02/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2023/02/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Git常用命令整理"><a href="#Git常用命令整理" class="headerlink" title="Git常用命令整理"></a>Git常用命令整理</h2><h3 id="Git-全局设置"><a href="#Git-全局设置" class="headerlink" title="Git 全局设置"></a>Git 全局设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;用户名&quot;<br>git config --global user.email &quot;用户邮箱&quot;<br></code></pre></td></tr></table></figure><h3 id="创建新的仓库并提交代码"><a href="#创建新的仓库并提交代码" class="headerlink" title="创建新的仓库并提交代码"></a>创建新的仓库并提交代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone 仓库地址<br>cd 仓库目录<br>git switch -c 新的分支名<br>touch README.md <br>git add README.md<br>git commit -m &quot;本次提交的描述信息&quot;<br>git push -u origin 新的分支名<br></code></pre></td></tr></table></figure><h3 id="推送本地现有文件夹"><a href="#推送本地现有文件夹" class="headerlink" title="推送本地现有文件夹"></a>推送本地现有文件夹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">cd 文件夹目录<br>git init <br>git remote add origin 远程仓库地址<br>git add .<br>git commit -m &quot;描述信息&quot;<br>git push -u origin 分支名<br></code></pre></td></tr></table></figure><h3 id="origin-的含义"><a href="#origin-的含义" class="headerlink" title="origin 的含义"></a>origin 的含义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">“git remote add origin 远程仓库地址”<br><br>origin 是 该远程仓库的别名<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">#克隆远程仓库的指定分支到本地<br>git clone -b 远程分支名 远程分支地址<br><br>#pull远程仓库的指定分支<br>git pull origin 远程指定分支<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习-将基本数据类型封装成包装类的好处</title>
    <link href="/2023/02/10/Java-%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E6%88%90%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <url>/2023/02/10/Java-%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E6%88%90%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Java学习-将基本数据类型封装成包装类的好处"><a href="#Java学习-将基本数据类型封装成包装类的好处" class="headerlink" title="Java学习-将基本数据类型封装成包装类的好处"></a>Java学习-将基本数据类型封装成包装类的好处</h2><ul><li>1.可以赋null值，有些地方需要赋null，但是基本数据类型不能赋null；</li></ul><ul><li><pre><code class="hljs"> 2.有缓存机制。例如Integer缓存了-128~127区间的数值；</code></pre></li><li><pre><code class="hljs"> 3.集合中只能存放Object及其子类 类型的数据，不能存放基本数据类型；</code></pre></li><li><pre><code class="hljs"> 可能还有其它的；</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习</category>
      
      <category>Wrapper类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Wrapper类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法-LeetCode_T40</title>
    <link href="/2023/02/08/T40/"/>
    <url>/2023/02/08/T40/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法-LeetCode-T40"><a href="#回溯算法-LeetCode-T40" class="headerlink" title="回溯算法_LeetCode_T40"></a>回溯算法_LeetCode_T40</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/combination-sum-ii">https://leetcode.cn/problems/combination-sum-ii</a></p></li></ul><h3 id="超时写法"><a href="#超时写法" class="headerlink" title="超时写法"></a>超时写法</h3><ul><li>回溯遍历所有组合；</li><li>最后对所有满足条件的组合进行去重；</li><li>ps：我一开始就是这么写的，然后直接提交，“超出时间限制”。</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>代码随想录给出的题解；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">( <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target )</span> &#123;<br>    <span class="hljs-comment">//为了将重复的数字都放到一起，所以先进行排序</span><br>    Arrays.sort( candidates );<br>    backTracking( candidates, target, <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">( <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start )</span> &#123;<br>    <span class="hljs-keyword">if</span> ( sum == target ) &#123;<br>      res.add( <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;( path ) );<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++ ) &#123;<br>      <span class="hljs-comment">//正确剔除重复解的办法</span><br>      <span class="hljs-comment">//跳过同一树层使用过的元素</span><br>      <span class="hljs-keyword">if</span> ( i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] ) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      sum += candidates[i];<br>      path.add( candidates[i] );<br>      <span class="hljs-comment">// i+1 代表当前组内元素只选取一次</span><br>      backTracking( candidates, target, i + <span class="hljs-number">1</span> );<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> path.getLast();<br>      sum -= temp;<br>      path.removeLast();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2023/02/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划一般解题步骤</title>
    <link href="/2023/02/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/"/>
    <url>/2023/02/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="动态规划一般解题步骤"><a href="#动态规划一般解题步骤" class="headerlink" title="动态规划一般解题步骤"></a>动态规划一般解题步骤</h3><ul><li><p><strong>确定dp数组以及下标含义</strong></p></li><li><p><strong>确定递推公式</strong></p></li><li><p><strong>dp数组如何初始化</strong></p></li><li><p><strong>确定遍历顺序</strong></p></li><li><p><strong>举例推导dp数组</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo上传文章、分类及标签等操作</title>
    <link href="/2023/02/07/Hexo%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%E3%80%81%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/02/07/Hexo%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%E3%80%81%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo上传文章、分类及标签等操作"><a href="#Hexo上传文章、分类及标签等操作" class="headerlink" title="Hexo上传文章、分类及标签等操作"></a>Hexo上传文章、分类及标签等操作</h2><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li>本地写好.md文档，复制到\source\_posts文件夹下；</li><li>在.md文档开头加上一下信息：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">title: 文章标题<br>date: 文章建立日期<br>categories：文章分类（可以有多级分类）<br>tags: 文章标签（可以有多个）<br></code></pre></td></tr></table></figure><p>参数列表及描述</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td></td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td><td></td></tr><tr><td>keywords</td><td>仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td><td></td></tr></tbody></table><ul><li>在git bash中输入 <strong>hexo g</strong> (完整命令为hexo generate)，用于生成静态文件；</li><li>输入<strong>hexo d</strong>(hexo deploy)发布到git仓库上；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建站纪念！</title>
    <link href="/2022/11/24/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5%EF%BC%81/"/>
    <url>/2022/11/24/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h2 id="建站纪念！"><a href="#建站纪念！" class="headerlink" title="建站纪念！"></a>建站纪念！</h2><h3 id="纪念日"><a href="#纪念日" class="headerlink" title="纪念日"></a>纪念日</h3><p><strong>本站出生于公元2022年11月24日，坐标北京市海淀区</strong></p><h3 id="为什么创建这个网站？"><a href="#为什么创建这个网站？" class="headerlink" title="为什么创建这个网站？"></a>为什么创建这个网站？</h3><p>本人是一名计算机专业在读硕士研究生，如本站大标题，趁年轻，多折腾。</p><p>如需进一步交流学习，可通过”关于”页面中的联系方式找到我。</p><p>欢迎大家来玩。</p><h3 id="本站内容的大致方向"><a href="#本站内容的大致方向" class="headerlink" title="本站内容的大致方向"></a>本站内容的大致方向</h3><ul><li>硕士期间，就目前来说，主要是做OpenHarmony相关的探索，因此，本站会发一些有关学习OpenHarmony的笔记。</li><li>LeetCode刷题记录。</li><li>Java学习笔记。</li><li>关于记录生活相关，南方人第一次去国际大都市读书，目前入学俩月多一点，还挺多感慨。（当然，后期应该会分享吐槽导师，读研生活以及读研经验等等）</li><li>后面再想想其他话题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
